<h1><a id="pevsdevops">Platform Engineering versus DevOps</a></h1>

<p>DevOps and platform engineering are similar and complementary concepts. In fact, many DevOps teams will have
    implemented aspects of platform engineering without necessarily thinking about it in those terms. But as DevOps
    teams look to provide DEaaS to help them scale, it is helpful to understand the relationship between platform
    engineering, DEaaS, and DevOps.</p>

<p>This first requires answering the seemingly innocuous question "What is DevOps?"</p>

<p>You can find many resources dedicated to DevOps, yet the concept can be very frustrating for those who've had to
    apply it meaningfully. To understand why DevOps has become so difficult to define, we'll instead seek to understand
    it by exploring the counterfactual "What is DevOps not?"</p>

<h2>What is DevOps not?</h2>

<p>The image below depicts a common interpretation of the DevOps lifecycle:</p>

<div><img alt="DevOps Lifecycle" src="images/devops-lifecycle.png"/></div>

<p>This image shows that DevOps encompasses planning, writing, testing, deploying, monitoring, and supporting software.
    The DevOps lifecycle is perhaps best summed up by a quote from Werner Vogels, Amazon's CTO, who said in 2006, "You
    build it, you run it."</p>

<p>We then have measurements that gauge the performance of DevOps teams. The DORA Accelerate State of DevOps report (<a
        href="https://oc.to/u7njwG">https://oc.to/u7njwG</a>) has 5 key metrics:</p>

<ol>
    <li>Deployment frequency</li>
    <li>Lead time for changes</li>
    <li>Change failure rate</li>
    <li>Time to restore service</li>
    <li>Reliability</li>
</ol>

<p>We referred to these as the DORA metrics. The report also links organizational performance to the
    characteristics described by Westrum's organizational culture
    (<a href="https://oc.to/r2TWX0">https://oc.to/r2TWX0</a>). This is where generative cultures high in trust and
    low in blame exhibit higher performance.</p>

<p>
    This means:
</p>

<ul>
    <li>The DevOps lifecycle makes DevOps teams responsible for tooling and processes</li>
    <li>Westrum's organizational culture makes them responsible for all human interactions</li>
    <li>The DORA metrics makes them responsible for all measurable outcomes</li>
</ul>

<p>And these are just 3 of the more popular perspectives on DevOps. One of the great successes of the DevOps
    movement is that it encourages new perspectives on the metrics, processes, ideals, and cultural underpinnings of the
    field.</p>

<p>But even with just the DevOps lifecycle, DORA metrics, and Westrum's organizational culture, we can attempt to answer
    the question “What is DevOps not?”</p>

<p>There is no satisfying answer to that question.</p>

<p>Without a clear internal structure in DevOps teams, the term DevOps can easily become unfalsifiable. This is because
    of the DevOps movement's goals. It unashamedly tries to break down silos and absorb responsibilities that previously
    separated teams creating and delivering technical solutions. Simultaneously it tries to build a culture of
    psychological safety to encourage creative problem-solving. The ideal DevOps team is self-sufficient, with the
    ability, willingness, confidence, and responsibility to tackle any and every problem.</p>

<p>But for every ideal DevOps team thriving with their clearly defined responsibilities and efficient processes, there's
    another team
    slowly drowning under the constant need to resolve every brittle process and incorporate every new responsibility
    encountered in the DevOps lifecycle. The mental burden of this undifferentiated and unsatisfying work has come to
    define their existence, leading to a downward spiral of dispirited and low-performing teams. Or, put more simply,
    teams with an unsatisfactory developer experience.</p>

<div><img class="icon" alt="Anecdotes Icon" src="images/anecdote.png"/></div>

<p><i>
    I found myself working as a developer on a codebase whose test suite would fail far more often than it passed. A few
    manual retries would solve the issue and ensure that pull requests could progress, although retrying the tests could
    take days.
</i></p>

<p><i>
    The suggestion proposed by the engineering leadership at the time was that everyone should stop what they were doing
    and fix the tests. This is typically sound advice and very much in line with practices like Test Driven Development
    (TDD). Unfortunately, every developer on the team intrinsically understood that fixing the tests was a dedicated
    project in its own right. There were no quick wins.
</i></p>

<p><i>
    This forced everyone to quietly calculate the tradeoffs between wasting days on test retries and devoting weeks to
    undertaking the unplanned work of fixing the tests. Needless to say, we ended up wasting a lot of time clicking that
    retry button.
</i>
</p>

<p><i>Fixing tests is arguably not the domain of platform engineering, as we'll see in the next section. But it is very
    much in the
    domain of DevOps. This example neatly highlights the dilemma faced by DevOps teams expected to take responsibility
    for every point of friction in their workflow. </i></p>

<h2>What is DevEx?</h2>

<p>The paper titled "DevEx: What Actually Drives Productivity" (<a href="https://oc.to/KHlp1Z">https://oc.to/KHlp1Z</a>)
    provides this definition of DevEx:</p>

<blockquote><p>Our framework distills developer experience to its three core dimensions: feedback loops, cognitive
    load, and flow state. These dimensions emerged from real-world application of our prior
    research, which identified 25 sociotechnical factors affecting DevEx. These three key dimensions crosscut those
    25 factors, providing a practical model for understanding DevEx.</p></blockquote>

<div><img alt="DevEx Core Dimensions" src="images/devex.png"/></div>

<h3>Feedback loops</h3>

<p>Software delivery involves many feedback loops:</p>

<ul>
    <li>Build and test times</li>
    <li>Code review waits</li>
    <li>Manual testing</li>
    <li>Real user feedback</li>
</ul>

<p>Each of these loops needs to be short to reduce friction. Ideally, all feedback loops should complete while the
    task is still active. If a task pauses during a feedback loop, it will interrupt the following work when it
    restarts, disrupting flow state and increasing cognitive load.</p>

<p>"DevEx: What Actually Drives Productivity" notes that:</p>

<blockquote><p>Studies have consistently shown that organizations deploying more frequently and maintaining shorter lead
    times are twice as likely to exceed performance goals as their competitors.</p></blockquote>

<h3>Cognitive load</h3>

<p>The tasks associated with the phases of the DevOps lifecycle involve large amounts of mental processing. This
    natural cognitive load for the task increases when developers have too many tools and technologies.</p>

<p>You can reduce cognitive load if you:</p>

<ol>
    <li>Reduce toolchain friction</li>
    <li>Keep documentation updated</li>
    <li>Improve the system's architecture</li>
    <li>Remove delays in the process</li>
</ol>

<h3>Flow state</h3>

<p>You can probably remember when you last felt in the flow. You may have had a good chunk of uninterrupted time and
    could focus on the problem. The problem seemed to resolve itself and you made great progress. You enjoyed the
    work.</p>

<p>Psychologist Mihaly Csikszentmihalyi studied the concept. He described it as a fully immersed feeling of energized
    focus.</p>

<p>Flow happens naturally when you have:</p>

<ol>
    <li>Control over your work structure</li>
    <li>Clear goals</li>
    <li>Engaging work</li>
</ol>

<p>It's not a case of making flow happen but preventing disruption from interruptions, delays, and context
    switching.</p>

<p>"DevEx: What Actually Drives Productivity" notes that:</p>

<blockquote><p>Frequent experiences of flow state at work lead to higher productivity, innovation, and employee
    development. Similarly, studies have shown that developers who enjoy their work perform better and produce
    higher-quality products.</p></blockquote>

<p>You can make flow more likely by:</p>

<ul>
    <li>Using asynchronous communication to avoid interruptions</li>
    <li>Clustering meetings to create large blocks of meeting-free time</li>
    <li>Avoiding or reducing the impact of unplanned work</li>
    <li>Batching questions</li>
</ul>

<h2>The impact of broken flow and high cognitive load</h2>

<p>DevOps is all about bringing together the people needed to deliver a technical solution to customers. The DevOps
    lifecycle describes the various disciplines required to deliver technical solutions, but a common mistake made by
    some DevOps managers is to assume that DevOps means no one should specialize and everyone should be able to
    implement any phase in the DevOps lifecycle at any time.</p>

<p>There are no hard rules dictating which of the DevOps lifecycle phases any given individual
    will focus on. However, the reality is DevOps team members will have skills and interests that align with a subset
    of phases.
    For example:</p>

<ul>
    <li>Developers may prefer coding, building, and testing software</li>
    <li>Those from an operations background may prefer building the platforms needed to monitor and
        operate software
    </li>
    <li>Product managers will likely focus on planning, testing, and releasing software</li>
</ul>

<p>Allowing DevOps team members to focus on a subset of the DevOps lifecycle gives them the opportunity to enter
    a state of flow. It also reduces the cognitive load incurred as a result of context switching.</p>

<p>However, when the implementation of DevOps makes it unfalsifiable, it forces everyone to do everything all
    the time. This kind of hyper-generalization may be necessary, and even desirable, during the initial stages of a new
    DevOps team. But when it's the norm in established DevOps teams, team members have reduced opportunities to
    establish a state of flow. Instead, they spend their time fighting one fire after another, often implementing the
    fastest and easiest solution before switching focus. This means feedback on any change is given after those
    responsible for the change have moved on, breaking feedback loops. In addition, the DevOps landscape is now so
    complex that no one can be reasonably expected to manage the cognitive load incurred by frequent and unplanned jumps
    to random phases in the DevOps lifecycle. This denies DevOps team members the opportunity to truly engage with their
    work, resulting in poor DevEx.</p>

<h2>What is Platform Engineering and DEaaS?</h2>

<p>If DevOps encapsulates literally everything that is required to deliver a technical product to a customer, then
    Platform Engineering is the catalyst to initiate and facilitate DevOps processes.</p>

<p>More specifically, Platform Engineering is the work undertaken by a platform team to deliver DEaaS. By aligning
    itself with established paradigms like IaaS, PaaS, and SaaS, DEaaS expresses the outcome of platform
    engineering (improved DevEx), its method of delivery (a self-service IDP), and who is responsible (the platform
    team) by:</p>

<ul>
    <li>
        Reducing the cognitive load to participate in the DevOps lifecycle, with tested processes and
        proven platforms
    </li>
    <li>
        Increasing the opportunities to enter a flow state by enabling DevOps team members to focus on the DevOps
        lifecycle phases that align with their skills and interests
    </li>
    <li>
        Improving feedback loops by ensuring DevOps teams use consistent processes, measure their own performance
        with standardized monitoring, and continually optimize processes with a shift-left mentality to identify
        problems early
    </li>
</ul>

<p>Describing Platform Engineering in terms of DEaaS also lets platform teams identify whether their work
    is focused on DEaaS or if it's more aligned with the kind of business as usual (BAU)
    work often performed by DevOps teams. This avoids the unfalsifiability of DevOps. The difference between DEaaS and
    other tasks is whether the work can be used as the foundation for a new project or team.</p>

<p>Consider that every major Operating System (OS) these days can host Virtual Machines (VMs). Does that mean you've
    implemented IaaS by giving every engineer a device with a modern OS? Of course not. IaaS requires provisioning a
    durable, accessible, supported, and monitored VM on demand, or at least with as little friction as possible.</p>

<p>Likewise, if spinning up a new project or team involves recreating processes and infrastructure from memory or
    reverse engineering settings from existing code bases and established systems, you haven't implemented DEaaS.
    This is true even if your work has been to improve DevEx by streamlining processes or refining the
    state of established platforms. This is because the knowledge about what decisions were made and why is only in the
    heads of a few key members of the DevOps team.</p>

<p>On the other hand, if you can use your IDP to spin up a new project or team, with confidence that best practices and
    hard-won business knowledge is baked into the foundation your IDP provides, then you have successfully implemented
    DEaaS. This one-to-many relationship between an IDP and the processes used by DevOps teams shows that
    architectural decisions are centrally defined and you can implement them on demand.</p>

<p>
    In the talk "Compliance standards should be modern development practices" (<a href="https://oc.to/zLvWzD">https://oc.to/zLvWzD</a>),
    Charity Majors, CTO of honeycomb.io, noted that:
</p>

<blockquote><p>
    I feel like in this industry we tend to spend so much more time on individual performance than we do on fine-tuning
    the sociotechnical system that we operate in, even though the systems that we're operating in have so much more of
    an impact on how well you can do your job than your own knowledge of data structures and algorithms.
</p></blockquote>

<p>Consider a world where we had no notion of a CI server. DevOps teams still have to build and test
    their code. This would likely lead to situations where every developer built their code locally, nominated a
    "builder" with the authority to produce golden artifacts, or maybe teams go a step further and implement a
    rudimentary centralized solution with cron jobs.
</p>

<p>Now imagine adding a second DevOps team. They, too, need a solution for building their code. There are 5 ways
    common requirements like this will be addressed:
</p>

<ul>
    <li>It won't be addressed at all</li>
    <li>It will be addressed with a novel solution</li>
    <li>It will be addressed with a coincidentally similar solution</li>
    <li>It will be addressed with a solution implemented from memory</li>
    <li>It will be addressed with a common solution</li>
</ul>

<p>It's easy to see that common solutions to common requirements are the only sustainable path for growing
    DevOps teams. They reduce the scope of responsibilities that DevOps teams must actively focus on. This directly
    decreases cognitive load while also increasing the opportunity to enter a state of flow.
</p>

<p>In our hypothetical scenario, the obvious solution is to deploy a CI server. But CI servers had to start somewhere.
    Jenkins, one of the most popular open source CI servers, was initially built by Kohsuke Kawaguchi
    (<a href="https://oc.to/kaK3ec">https://oc.to/kaK3ec</a>):
</p>

<blockquote><p> Kohsuke was a developer at Sun and got tired of incurring the wrath of his team every time
    his code broke the build. He created Jenkins as a way to perform continuous integration – that is, to test
    his code before he did an actual commit to the repository, to be sure all was well. Once his teammates saw
    what he was doing, they all wanted to use Jenkins.</p></blockquote>

<p>Thus, a common solution to a common requirement was born. It's also no coincidence that Jenkins was born to improve
    Kohsuke's DevEx.</p>

<p>While CI servers are a solved problem (at least for most DevOps teams), environments with multiple DevOps teams
    working side-by-side will no doubt have many more common requirements. Addressing these common requirements with
    artifacts generated by your IDP is the goal of a platform team.
</p>

<h2>What is an IDP?</h2>

<p>
    An IDP is the interface DevOps teams use to implement DEaaS. It may be as simple as a wiki, or as complex as
    a specialized platform exposing a Command Line Interface (CLI), an Application Programming Interface (API), or
    web interface.
</p>

<p>
    In the previous section we noted that an IDP should provide common solutions to common requirements. Common
    solutions to common requirements are "architecture" as defined by “Objects, Components,
    and Frameworks With UML: The Catalysis Approach” by Desmond D'Souza and Alan Wills (<a
            href="https://oc.to/sjdtWf">https://oc.to/sjdtWf</a>):</p>

<blockquote><p>The set of design decisions about any system (or smaller component) that keeps its
    implementors and maintainers from exercising needless creativity.</p></blockquote>

<p>
    We then define the requirements of an IDP as:
</p>

<ul>
    <li>A central repository of architectural decisions made by DevOps teams</li>
    <li>The ability to implement architectural decisions throughout DevOps teams at scale</li>
    <li>Feedback processes that allow architectural decisions to be improved over time</li>
</ul>

<p>
    Common artifacts implementing architectural decisions maintained by an IDP include:
</p>
<ul>
    <li>Software project templates</li>
    <li>CI/CD pipelines templates</li>
    <li>IaC templates</li>
    <li>Scripts to configure local development environments</li>
    <li>Document and presentation templates</li>
    <li>Dashboard templates</li>
    <li>Checklists for starting new projects</li>
    <li>Reference architectures</li>
</ul>

<h2>Conclusion</h2>

<p>DevOps is arguably the best philosophy we have to build high-performing teams to deliver technical solutions. But
    while DevOps can be used as the foundation for great teams, the demands placed on them must be matched
    by their capability. Asking DevOps teams to provide their own unique implementation to every requirement leads to
    inconsistent solutions at best and eventually creates an unsustainable environment. This in turn leads to
    a loss of flow, high cognitive load, and slow feedback cycles - all signs of poor DevEx.</p>

<p>
    This chapter describes platform engineering as the work done by platform teams to build an IDP. The IDP provides
    the interface through which DevOps teams implement architectural decisions. This allows DevOps teams to
    focus on meaningful problems rather than being distracted by undifferentiated work. This in turn improves their DevEx,
    which is the goal of DEaaS.
</p>