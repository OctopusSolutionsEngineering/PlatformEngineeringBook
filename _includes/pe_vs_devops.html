<h1><a id="pevsdevops">Platform Engineering vs. DevOps</a></h1>

<p>You can find many resources dedicated to DevOps, yet the concept can be very frustrating for those who have had to apply
    it meaningfully. To understand why DevOps has become so contentious, we will investigate it by exploring the
    counterfactual "What is DevOps not?"</p>

<h2>What is DevOps Not?</h2>

<p>The image below depicts a common interpretation of the DevOps lifecycle:</p>

<div><img alt="DevOps Lifecycle" src="images/devops-lifecycle.png"/></div>

<p>This image shows that DevOps encompasses planning, writing, testing, deploying, monitoring, and supporting software.
    The DevOps lifecycle is perhaps best summed up by a quote from Werner Vogels, Amazon's CTO, who said in 2006, "You
    build it, you run it."</p>

<p>We then have measurements that gauge the performance of DevOps teams. The DORA Accelerate State of DevOps report has
    five key metrics: deployment frequency, lead time for changes, change failure rate, time to restore service, and
    reliability. These are referred to as the DORA metrics. The report also links organizational performance to the
    characteristics described by Westrum's organizational culture (<a href="https://oc.to/r2TWX0">https://oc.to/r2TWX0</a>), where generative cultures high
    in trust and low in blame exhibit higher performance.</p>

<p>These definitions show us that the processes and cultural foundations that support and improve the delivery of
    features, reduce defects, and reduce the time to resolve issues are all the responsibility of DevOps teams.</p>

<p>And these are just two of the more popular interpretations of DevOps. One of the great successes of the DevOps
    movement is that it encourages new perspectives on the metrics, processes, ideals, and cultural underpinnings of the
    field.</p>

<p>But even with just the DevOps lifecycle, DORA metrics, and Westrum organizational culture, we can attempt to answer
    the question “What is DevOps not?”</p>

<p>There is no satisfying answer to that question. The term DevOps has become almost unfalsifiable, but this is quite by
    design. DevOps has unashamedly sought to break down silos and absorb responsibilities that previously separated teams
    creating and delivering technical solutions, while simultaneously building a culture of psychological safety to
    encourage creative problem solving. The ideal DevOps team is self-sufficient, with the ability,
    willingness, confidence, and responsibility to tackle any and every problem.</p>

<p>But for every ideal DevOps team thriving on the responsibility of owning their own destiny, there is another team slowly
    drowning under the constant need to resolve every brittle process they encounter in the DevOps lifecycle. The mental
    burden of this undifferentiated and unsatisfying work has come to define their existence, leading to a downward
    spiral of dispirited and low performing teams. Or, put more simply, teams with an unsatisfactory developer
    experience.</p>

<p><i>
    I found myself working as a developer on a codebase whose test suite would fail far more often than it passed. A few manual retries
    would solve the issue and ensure that pull requests could progress, although retrying the tests could take days.
</i></p>
    
<p><i>
    The suggestion proposed by the engineering leadership at the time was that everyone should stop what they were doing and fix the
    tests. This is typically sound advice, and very much in line with practices like Test Driven Design (TDD). Unfortunately, every developer
    on the team intrincially understood that fixing the tests was a dedicated project it its own right. There were no quick wins.
</i></p>

<p><i>
    This forced everyone to quietly calculate the tradeoffs between wasting days on test retries and devoting weeks to undertaking
        the unplanned work of fixing the tests. Needless to say, we ended up wasting a lot of time clicking that retry button.
</i>
</p>

<p><i>Fixing tests is arguably not the domain of platform engineering, as we'll see in the next section. But is is very much in the 
    domain of DevOps. This example neatly highlights the delima faced by DevOps teams expected to take responsibility for every 
    point of friction in their workflow. </i></p>

<h2>What is Platform Engineering?</h2>

<p>If DevOps encapsulates literally everything that is required to deliver a technical product to a customer, then
    platform engineering is the catalyst to initiate and facilitate DevOps processes. By delivering DevEx as a Service
    through an IDP, platform teams improve the velocity of DevOps teams, increase the quality and consistency of their
    work, remove points of friction that DevOps teams find so frustrating, and do so in a repeatable and scalable
    manner.</p>

<p>By aligning itself with established paradigms like IaaS, PaaS, and SaaS, DEaaS expresses the goal of platform
    engineering (improved DevEx) and its method of delivery (a self-service IDP).</p>

<p>Describing platform engineering in terms of DEaaS also allows platform teams to identify whether their work
    contributes to the goal of platform engineering or if it is more aligned with the kind of Business as Usual (BAU)
    work often performed by DevOps teams. This avoids the unfalsifiability of DevOps. The difference between DEaaS and
    other tasks is whether the work can be used as the foundation for a new project or team.</p>

<p>Consider that every major Operating System (OS) these days has the ability to host VMs. Does that mean you have
    implemented IaaS by giving every engineer a device with a modern OS? Of course not. IaaS requires the ability to
    provision a durable, accessible, supported, and monitored VM on demand, or at least with as little friction as
    possible.</p>

<p>In the same manner, if spinning up a new project or team involves recreating processes and infrastructure from memory
    or reverse engineering settings from existing code bases and established systems, you have not implemented platform
    engineering. This is true even if your work has been to improve DevEx by streamlining processes or refine the state
    of established platforms, as the knowledge about what decisions were made, and why, is only held in the heads of a
    few key members of the DevOps team.</p>

<p>On the other hand, if you can leverage your IDP to spin up a new project or team, with confidence that best practices
    and hard won business knowledge is baked into the foundation your IDP provides, then you have successfully
    implemented platform engineering. This one-to-many relationship between an IDP and the processes used by DevOps
    teams demonstrates that architectural decisions are centrally defined and can be implemented on demand.</p>

<p>
    Common artifacts generated by an IDP include:
</p>
<ul>
    <li>Software project templates</li>
    <li>CI/CD pipelines templates</li>
    <li>IaC templates</li>
    <li>Scripts to configure local development environments</li>
    <li>Document and presentation templates</li>
    <li>Dashboard templates</li>
    <li>Checklists for starting new projects</li>
    <li>Reference architectures</li>
</ul>

<h2>Conclusion</h2>

<p>DevOps is arguably the best philosophy we have to build high performing teams to deliver technical solutions. But
    just because DevOps can be used as teh foundation for great teams, there is no guarantee that it will.</p>

<p>Platform engineering is an acknowledgment that common problems are best solved with common solutions, and that
    solving common problems is one of the most effective methods for improving DevEx.</p>

<p>By delivering DevEx as a Service, platform teams are responsible for an IDP that ensures architectural decisions,
    best practices, and business knowledge is codified and able to be implemented at scale throughout DevOps teams. A
    one-to-many relationship between an IDP and DevOps processes is a clear sign that you are doing platform engineering
    right.</p>