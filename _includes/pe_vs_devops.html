<h1><a id="pevsdevops">Platform Engineering vs. DevOps</a></h1>

<p>You can find many resources dedicated to DevOps, yet the concept can be very frustrating for those who have had to
    apply
    it meaningfully. To understand why DevOps has become so contentious, we will investigate it by exploring the
    counterfactual "What is DevOps not?"</p>

<h2>What is DevOps Not?</h2>

<p>The image below depicts a common interpretation of the DevOps lifecycle:</p>

<div><img alt="DevOps Lifecycle" src="images/devops-lifecycle.png"/></div>

<p>This image shows that DevOps encompasses planning, writing, testing, deploying, monitoring, and supporting software.
    The DevOps lifecycle is perhaps best summed up by a quote from Werner Vogels, Amazon's CTO, who said in 2006, "You
    build it, you run it."</p>

<p>We then have measurements that gauge the performance of DevOps teams. The DORA Accelerate State of DevOps report has
    five key metrics: deployment frequency, lead time for changes, change failure rate, time to restore service, and
    reliability. These are referred to as the DORA metrics. The report also links organizational performance to the
    characteristics described by Westrum's organizational culture (<a
            href="https://oc.to/r2TWX0">https://oc.to/r2TWX0</a>), where generative cultures high
    in trust and low in blame exhibit higher performance.</p>

<p>So the DevOps lifecycle makes DevOps teams responsible for tooling and processes, Westrum's organizational
    cultures makes them responsible for all human interactions, and the DORA metrics makes them responsible for all
    measurable outcomes.</p>

<p>And these are just three of the more popular perspectives on DevOps. One of the great successes of the DevOps
    movement is that it encourages new perspectives on the metrics, processes, ideals, and cultural underpinnings of the
    field.</p>

<p>But even with just the DevOps lifecycle, DORA metrics, and Westrum's organizational culture, we can attempt to answer
    the question “What is DevOps not?”</p>

<p>There is no satisfying answer to that question.</p>

<p>The term DevOps has become almost unfalsifiable, but this is quite by
    design. DevOps has unashamedly sought to break down silos and absorb responsibilities that previously separated
    teams creating and delivering technical solutions, while simultaneously building a culture of psychological safety
    to encourage creative problem-solving. The ideal DevOps team is self-sufficient, with the ability, willingness,
    confidence, and responsibility to tackle any and every problem.</p>

<p>But for every ideal DevOps team thriving on the responsibility of owning their own destiny, there is another team
    slowly drowning under the constant need to resolve every brittle process and incorporate every new responsibility
    encountered in the DevOps lifecycle. The mental burden of this undifferentiated and unsatisfying work has come to
    define their existence, leading to a downward spiral of dispirited and low performing teams. Or, put more simply,
    teams with an unsatisfactory developer experience.</p>

<div><img class="icon" alt="Anecdotes Icon" src="images/anecdote.png"/></div>

<p><i>
    I found myself working as a developer on a codebase whose test suite would fail far more often than it passed. A few
    manual retries would solve the issue and ensure that pull requests could progress, although retrying the tests could
    take days.
</i></p>

<p><i>
    The suggestion proposed by the engineering leadership at the time was that everyone should stop what they were doing
    and fix the tests. This is typically sound advice and very much in line with practices like Test Driven Design
    (TDD). Unfortunately, every developer on the team intrinsically understood that fixing the tests was a dedicated
    project it its own right. There were no quick wins.
</i></p>

<p><i>
    This forced everyone to quietly calculate the tradeoffs between wasting days on test retries and devoting weeks to
    undertaking the unplanned work of fixing the tests. Needless to say, we ended up wasting a lot of time clicking that
    retry button.
</i>
</p>

<p><i>Fixing tests is arguably not the domain of platform engineering, as we'll see in the next section. But it is very
    much in the
    domain of DevOps. This example neatly highlights the dilemma faced by DevOps teams expected to take responsibility
    for every point of friction in their workflow. </i></p>

<h2>What is Platform Engineering?</h2>

<p>If DevOps encapsulates literally everything that is required to deliver a technical product to a customer, then
    platform engineering is the catalyst to initiate and facilitate DevOps processes. By delivering DevEx as a Service
    through an IDP, platform teams improve the velocity of DevOps teams, increase the quality and consistency of their
    work, remove points of friction that DevOps teams find so frustrating, and do so in a repeatable and scalable
    manner.</p>

<p>By aligning itself with established paradigms like IaaS, PaaS, and SaaS, DEaaS expresses the goal of platform
    engineering (improved DevEx) and its method of delivery (a self-service IDP).</p>

<p>Describing platform engineering in terms of DEaaS also allows platform teams to identify whether their work
    contributes to the goal of platform engineering or if it is more aligned with the kind of Business as Usual (BAU)
    work often performed by DevOps teams. This avoids the unfalsifiability of DevOps. The difference between DEaaS and
    other tasks is whether the work can be used as the foundation for a new project or team.</p>

<p>Consider that every major Operating System (OS) these days has the ability to host Virtual Machines (VMs). Does that
    mean you have
    implemented IaaS by giving every engineer a device with a modern OS? Of course not. IaaS requires the ability to
    provision a durable, accessible, supported, and monitored VM on demand, or at least with as little friction as
    possible.</p>

<p>In the same manner, if spinning up a new project or team involves recreating processes and infrastructure from memory
    or reverse engineering settings from existing code bases and established systems, you have not implemented platform
    engineering. This is true even if your work has been to improve DevEx by streamlining processes or refine the state
    of established platforms, as the knowledge about what decisions were made, and why, is only held in the heads of a
    few key members of the DevOps team.</p>

<p>On the other hand, if you can leverage your IDP to spin up a new project or team, with confidence that best practices
    and hard won business knowledge is baked into the foundation your IDP provides, then you have successfully
    implemented platform engineering. This one-to-many relationship between an IDP and the processes used by DevOps
    teams demonstrates that architectural decisions are centrally defined and can be implemented on demand.</p>

<p>
    In her talk <a href="https://oc.to/zLvWzD">Compliance standards should be modern development practices</a>,
    Charity Majors, CTO of honeycomb.io, noted that:
</p>

<blockquote>
    I feel like in this industry we tend to spend so much more time on individual performance than we do on fine-tuning
    the sociotechnical system that we operate in, even though the systems that we're operating in have so much more of
    an impact on how well you can do you job that your own knowledge of data structures and algorithms.
</blockquote>

<p>Consider a world where we had no notion of a CI server. DevOps teams still have the requirement to build and test
    their
    code, which would likely lead to situations where every developer built their code locally, nominated a
    "builder" with the authority to produce golden artifacts, or maybe teams go a step further and implement a
    rudimentary
    centralized solution with cron jobs.
</p>

<p>Now imagine adding a second DevOps team. They, too, need a solution for building their code. There are five ways
    common requirements like this will be addressed:
</p>

<ul>
    <li>It won't be addressed at all</li>
    <li>It will be addressed with a novel solution</li>
    <li>It will be addressed with a coincidentally similar solution</li>
    <li>It will be addressed with a solution implemented from memory</li>
    <li>It will be addressed with a common solution</li>
</ul>

<p>It is easy to see that common solutions to common requirements are the only sustainable path for growing
    DevOps teams. While the unfalsifiability of the responsibilities assigned to DevOps teams is still a concern, common
    solutions to common requirements do reduce the scope of those responsibilities that DevOps teams must
    actively focus on.
</p>

<p>
    In his book "Drive", Daniel H. Pink argues that supporting employees in the areas of autonomy, mastery, and purpose
    results in increased performance and satisfaction. But no one gains autonomy, mastery, and purpose solving the same
    problems over and over.
</p>

<p>In our hypothetical scenario, the obvious solution is to deploy a CI server. But CI servers had to start somewhere.
    Jenkins, one of the most popular open source CI servers, was initially built by Kohsuke Kawaguchi
    (<a href="https://oc.to/kaK3ec">https://oc.to/kaK3ec</a>):
</p>

<blockquote> Kohsuke was a developer at Sun and got tired of incurring the wrath of his team every time
    his code broke the build. He created Jenkins as a way to perform continuous integration – that is, to test
    his code before he did an actual commit to the repository, to be sure all was well. Once his teammates saw
    what he was doing, they all wanted to use Jenkins.</blockquote>

<p>Thus, a common solution to a common requirement was born. It is also no coincidence that Jenkins was born to improve
    Kohsuke's DevEx.</p>

<p>While CI servers are a solved problem (at least for most DevOps teams), environments with multiple DevOps teams
    working side by side will no doubt have many more common requirements. Addressing these common requirements with
    artifacts generated by your IDP is the goal of a platform team.
</p>


<p>
    Common artifacts generated by an IDP include:
</p>
<ul>
    <li>Software project templates</li>
    <li>CI/CD pipelines templates</li>
    <li>IaC templates</li>
    <li>Scripts to configure local development environments</li>
    <li>Document and presentation templates</li>
    <li>Dashboard templates</li>
    <li>Checklists for starting new projects</li>
    <li>Reference architectures</li>
</ul>

<h2>Conclusion</h2>

<p>DevOps is arguably the best philosophy we have to build high performing teams to deliver technical solutions. But
    while DevOps can be used as the foundation for great teams, the demands placed on them must be matched
    by their capability. Asking DevOps teams to provide their own unique implementation to every requirement leads to
    inconsistent solutions at best and eventually creates an unsustainable environment. This in turn leads to
    frustration and poor DevEx.</p>

<p>Platform engineering is an acknowledgment that common problems are best addressed with common solutions, and that
    solving common problems is one of the most effective methods for improving DevEx.</p>

<p>By delivering DevEx as a Service, platform teams are responsible for an IDP that ensures architectural decisions,
    best practices, and business knowledge is codified and able to be implemented at scale throughout DevOps teams. A
    one-to-many relationship between an IDP and DevOps processes is a clear sign that you are doing platform engineering
    right.</p>