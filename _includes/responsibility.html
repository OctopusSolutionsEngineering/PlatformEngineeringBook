<h1><a id="responsibility">Platform Engineering Responsibility Models</a></h1>

<p>A primary goal of any platform team is to never block internal customers from achieving their goals while providing
    solutions that remove the need to reimplement solved problems.</p>

<p>This quote from Peter Gillard-Moss of Thougtworks in the blog post “Platform Tech Strategy: The Three Layers“
    (<a href="https://oc.to/Ka3d7I">https://oc.to/Ka3d7I</a>) sums it up nicely:</p>

<p class="quote">Platforms are a means of centralizing expertise while decentralizing innovation to the
    customer or user.</p>

<p>We can also draw inspiration from the definition of "architecture" from “Objects, Components, and Frameworks With
    UML: The Catalysis Approach” by Desmond D'Souza and Alan Wills (<a
            href="https://oc.to/sjdtWf">https://oc.to/sjdtWf</a>):</p>

<p class="quote">The set of design decisions about any system (or smaller component) that keeps its
    implementors and maintainers from exercising needless creativity.</p>

<p>These quotes show that the platform team aims to give customers the freedom to innovate while discouraging the
    tendency to indulge in the "needless creativity" often associated with delivering new solutions to already solved
    problems.</p>

<p>Achieving this balance requires deliberate decisions about who has responsibility for artifacts generated by your
    IDP. This chapter explores the three common ways in which responsibility is assumed by, or shared with, the platform
    team and your customers.</p>

<h2>Customer Responsibility</h2>

<p>The easiest way to think about customers taking responsibility for the artifacts generated by your IDP is to think of
    copying a template document from a read-only shared drive into the customer’s home directory.</p>

<p>While you must make every attempt to ensure the template is fit for purpose and of high quality, once a customer
    makes a copy, they assume responsibility for using, editing, and updating that copy. Existing copies do not receive
    updates to the source template document.</p>

<p>In the same way, your IDP does not provide updates for artifacts like sample projects or scripts, deployment
    pipelines, or example dashboards. The platform team only supports them in a limited fashion once a customer has
    taken ownership under a customer responsibility model.</p>

<p>This model reduces the likelihood that the platform team will block their customers. If the artifacts are
    insufficient or require change, customers have the freedom and responsibility to do it themselves.</p>

<p>The downside to this model is that it does not allow for automatic updates to artifacts generated by the IDP. The
    disconnected nature of artifacts distributed under the customer responsibility model limits the ability of the
    platform team to propagate improvements.</p>

<p>Heavily modifiable artifacts are well suited to this model. For example, a "hello world" style software project
    template that embeds standard settings, like dependency repositories, common build scripts, and a skeletal folder
    structure, is an ideal candidate for the customer responsibility model, as customers will drastically alter this
    project template almost immediately.</p>

<p>
    The customer responsibility model can be thought of as an "eventual inconsistency" model where teams start with
    the same foundation by diverge as they customize their solution.
</p>

<div><img alt="DevOps Lifecycle" src="images/customer-responsibility-model.png"/></div>

<h2>Shared Responsibility</h2>

<p>The shared responsibility model allows the customer and the platform team to modify an IDP artifact after creation.
    An
    example of this model is the process of forking a Git repository. Because both Git repositories share the same
    history, it is possible to merge changes between them while retaining any local changes.</p>

<p>This model may involve the platform engineering team pushing changes, the customer pulling changes, or
    both.</p>

<p>Git is an excellent example of the shared responsibility model and one of the most practical ways to implement it.
    The merging strategies implemented by Git do an excellent job of tracking changes (as opposed to simply finding
    differences between files). By having your IDP generate Git repositories as artifacts, it becomes possible to merge
    the downstream (or customer controlled) repositories and upstream (or IDP controlled) repositories.</p>

<p>Git is not a requirement to implement the shared repository model, though. A regular diff between two plain text
    files may be sufficient for customers and the platform team to consolidate changes made by each other. As a
    fallback, copy and paste may suffice to synchronize changes.</p>

<p>Like the customer responsibility model, the shared responsibility model helps prevent the platform team from being a
    blocker, as customers have the ability and responsibility to update their artifacts to resolve any issues.</p>

<p>The shared responsibility model can propagate changes from artifacts maintained by the IDP to those
    maintained by the customer.</p>

<p>However, be aware that it may not be reasonable, or even possible, to propagate changes to heavily modified customer
    artifacts. In these situations, there will need to be an agreement on who does the work of merging changes.
    Customers may be happy to pull in changes as required, or the platform team may need to do the work to push changes
    out.</p>

<p>
    The shared responsibility model represents an "eventual consistency" model where the platform team and their
    customers
    work in parallel and eventually merge any useful changes.
</p>

<div><img alt="DevOps Lifecycle" src="images/shared-responsibility-model.png"/></div>

<h2>Centralized Responsibility</h2>

<p>The centralized responsibility model gives customers read-only or locked-down copies of any generated artifacts.
    While customers are free to use these artifacts, they have little or no ability to customize them.</p>

<p>An analogy is a virus scanner deployed to your workstation by the security team. You can run the virus scanner, but
    you cannot configure it. A central team manages any updates to the virus scanner or its configuration.</p>

<p>In the same way, customers can use a deployment pipeline distributed under the centralized responsibility model to
    deploy their software, but they cannot edit the pipeline.</p>

<p>The centralized responsibility model allows the platform team to push out changes quickly. Because the artifacts are
    always in a known state or the platform team can overwrite any changes, it becomes much easier to update artifacts
    at scale. This model is easy to implement with common Infrastructure as Code (IaC) tools like Terraform,
    CloudFormation, and Azure Arm Templates.</p>

<p>The downside to this model is that you risk blocking your customers. If the artifacts you provide have faults or
    limitations, it is entirely up to you as a platform team member to push out updates to unblock your customers.</p>

<p>This model suits simple and extensively tested artifacts, such as scripts to perform backups or restart services.
    Unfortunately, this model tends to fail when distributing more complex artifacts. As Gregor Hohpe put it in his
    presentation "The Magic of Platforms" (<a href="https://oc.to/bWjWFK">https://oc.to/bWjWFK</a>):</p>

<p class="quote">There are two ways to build a platform:</p>

<ol class="quote">
    <li>Be smarter than everyone else and anticipate all their needs</li>
    <li>Evolve the platform based on user needs, which can be sensed from platform usage</li>
</ol>

<p class="quote">One is more likely than the other.</p>

<p>As your IDP gains traction, your customer's requirements will test the bounds of complex artifacts distributed under
    the centralized responsibility model.</p>

<p>
    The centralized responsibility model is an "enforced consistency" model where the platform team retains most of the
    control of any artifacts generated by the IDP.
</p>

<div><img alt="DevOps Lifecycle" src="images/central-responsibility-model.png"/></div>

<h2>Customization as Feedback</h2>

<p>In the chapter "Planning your Internal Developer Platform", we noted that feedback was an important activity to
    undertake as part of a product mindset.</p>

<p>Metrics like NPS or CSAT are appealing because they can be automated and asynchronous but may be of limited value
    with small sample sizes. And while scheduling feedback sessions with your customers is relatively easy, since your
    customers are typically also your colleagues, this process is time-consuming.</p>

<p>Another feedback option is to observe the changes made by customers to the artifacts generated by your IDP. This
    asynchronous feedback mechanism provides high-quality insights into how your customers want to use your
    platform.</p>

<p>The idea is similar to desire paths. The ABC News article “What desire paths can tell us about how to design safer,
    better public spaces” (<a href="https://oc.to/tVhtZ4">https://oc.to/tVhtZ4</a>) provides this definition:</p>

<p class="quote">A desire line, or desire path, is an unplanned trail that forms as a result of traffic, either by
    humans or other
    animals, and often veers away from conventional paths.</p>

<p>You may have seen desire paths yourself as dirt tracks that cut a more direct line between paved paths or through
    vegetation.</p>

<p>The same idea applies to the artifacts produced by your IDP. Suppose your customers have edited them to suit their
    purposes. Those edits must be considered valuable feedback indicating that the source artifacts may require
    modification to support their intended use case.</p>

<h2>The Responsibility Triad</h2>

<p>You will have three competing concerns as you develop your IDP, captured in the responsibility triad:</p>
<ol>
    <li>To have many artifacts</li>
    <li>To centrally update existing artifacts</li>
    <li>To have end-users modify their artifacts</li>
</ol>

<p>In practice, you can optimize any two concerns of the responsibility triad:</p>
<ol>
    <li>You can have many artifacts and update those artifacts over time. However, customers will have limited ability
        to modify those artifacts.
    </li>
    <li>You can have many artifacts and allow customers to modify those artifacts. But you'll have limited ability to
        update those artifacts centrally.
    </li>
    <li>You can centrally update artifacts and have customers modify them. But you will only be able to support a few
        artifacts.
    </li>
</ol>

<div><img alt="DevOps Lifecycle" src="images/optimize-for-any-two.png"/></div>

<p>Platform teams must plan for the trade-offs imposed by the responsibility triad; otherwise, teams will unexpectedly
    paint themselves into one of its corners. There are common strategies for platform teams that ensure
    the trade-offs are intentional.</p>

<p>Initially, your mission statement must limit the number of created artifacts. Deploying too many artifacts without
    building the muscle to update those artifacts will leave you with a graveyard of good intentions.</p>

<p>Policies or other restrictions that limit how much customers can edit shared responsibility artifacts reduce the
    burden of centrally pushing changes. For example, if customers could edit steps 2 and 3 in a deployment process,
    while steps 1, 4 and 5 are read-only, the platform team could reliably publish updates to the read-only steps
    without affecting customer modifications.</p>

<p>Providing read-only processes but supporting customer-edited variables is a specialized policy that allows customers
    to customize their artifacts while ensuring the platform team has a stable target for centralized updates.</p>

<p>Maintaining multiple versions of your artifacts allows you to add new features to later versions while distributing
    only critical fixes to previous versions. The SemVer versioning scheme, which uses a x.y.z scheme, captures this
    idea as major version (or x version) increment. This allows your customers to treat artifact updates like software
    updates and schedule the integration of new major versions when needed.</p>

<p>Preferencing the customer responsibility model over the shared responsibility model limits the burden on the platform
    team to resolve conflicts in edited artifacts. The centralized responsibility model also reduces the conflict burden
    but has the downside of potentially making the IDP a blocker for your customers.</p>

<p>Passing the responsibility to merge changes to the customer has the effect of outsourcing the work of resolving
    conflicts. This strategy relies heavily on your feedback channels, as this is how you make your customers aware of
    any pending changes and the urgency with which to perform updates.</p>

<p>The one plan that will eventually fail is to try and deploy a vast number of customizable artifacts and then try to
    centrally maintain them over time. An IDP is only as valuable as its ability to affect change at scale, and keeping
    the responsibility triad in mind as you develop your IDP ensures its scalability over the long term.</p>

<h2>Choosing a Responsibility Model</h2>

<p>Those looking to introduce platform engineering into existing DevOps teams face three common realities:</p>

<ul>
    <li>Your IDP is a greenfield project</li>
    <li>Your platform team must reduce the mental burden of an existing, complex environment</li>
    <li>Your customers are technically adept</li>
</ul>

<p>
    The purpose of an IDP is to generate opinionated artifacts embedding the accumulated business knowledge and best
    practices learned by your customers over the years. By design, these artifacts abstract away much of the tribal
    knowledge required to build high quality solutions, allowing DevOps teams to focus on solving novel problems rather
    than duplicating the effort required to solve already solved problems.
</p>

<p>
    The challenge when developing such abstractions is to strike the right balance between hiding complexity and
    enabling flexibility.
</p>

<p>
    Platform teams have the added challenge of being compared to the established platforms their IDP seeks to
    abstract away. The reality is that these existing platforms were adopted because of the many years, countless hours,
    and eye-watering sums of money that were spent refining the balance between complexity and flexibility. For example,
    popular operating systems, hypervisors, cloud platforms, and container orchestration platforms all have billions
    of dollars worth of development behind them.
</p>

<p>
    Meanwhile, a good number of your customers will be comfortable with these underlying platforms, meaning they will
    quickly
    spot, and likely be frustrated by, the limitations of your abstractions. This risks making your IDP the kind of
    blocker that it was supposed to remove.
</p>

<p>
    It is not a question of whether abstractions are valuable or possible to build correctly, as every successful piece
    of
    technology is an example of building a useful abstraction: a car abstracts the complexity of an engine and
    transmission behind a steering wheel, accelerator, and brake; an electrical powerpoint abstracts the continent sized
    infrastructure of a power grid; and a phone abstracts a worldwide communication network. The better question,
    especially for new platform teams, is whether you have the knowledge to create the correct level of abstraction?
</p>

<p>
    The only safe initial answer to this question is "No", with an aim to reach the point where the answer is "Yes,
    but...".
    While you will never have perfect knowledge of your customer's needs, a successful platform team can refine their
    abstractions over time. But you do need to have some level of early success to earn the time required to refine
    the artifacts provided by your IDP.
</p>

<p>
    Anyone aiming to provide an opinionated solution faces this same dilemma, but the survivorship bias of every
    successful abstraction you see in daily life can make it seem like building abstractions is easy. However, new
    platform teams must assume building abstractions is, in fact, quite difficult, and therefore have a plan to support
    customers with unique needs or opinions of their own. This is the crux of the previously discussed responsibility
    models:
</p>

<ul>
    <li>
        Centralized responsibility (or "enforced consistency") artifacts provide highly opinionated solutions exposing a
        relatively small number of
        options to customize the end result. The
        success of the centralized responsibility model is highly dependent on how closely aligned your abstractions are
        to the needs of your customers.
    </li>
    <li>
        Shared responsibility (or "eventual consistency") artifacts can be modified by customers, providing them with
        the ability to customize their
        solution while still allowing the platform team to centrally distribute updates. These artifacts are the most
        flexible and provide a sliding scale between enforcing opinions and exposing flexibility (with the caveat that
        increased
        customization will typically decrease the ability to centrally distribute updates). The shared responsibility
        model assumes abstractions will be imperfect and emphasises a workflow allowing platform teams and their
        customers to jointly refine the solution over time.
    </li>
    <li>
        Customer responsibility (or "eventual inconsistency") artifacts provide customers with a base template that they
        are expected to own and
        modify to suit their needs. While the templates can provide an initial set of opinions, they are
        expected to be heavily modified. The customer responsibility model assumes customers will keep what is useful
        and discard what is not.
    </li>
</ul>

<p>
    An anti-pattern to avoid when starting a new platform team is focusing too heavily on the centralized responsibility
    model. This
    model requires that you build the most accurate abstractions, and starting a new platform team is the time when you
    have the least amount of information to do so.
</p>

<p>
    Instead, new platform teams should aim to initially offer artifacts under the shared responsibility or customer
    responsibility models.
</p>

<p>
    To put the difficulty of designing abstractions into perspective, consider that Kubernetes added the Deployment
    resource in version 1.2 to expand on the capabilities of a ReplicaSet and has been working since 2019 to introduce
    the Gateway resource to address limitations with Ingresses. These are just two examples of the constant refinement
    platforms like Kubernetes undergo as they find the most effective level of abstraction. And all of this is after
    the many years that Borg, the predecessor to Kubernetes, was under development internally in Google, as noted in the
    blog post <a href="https://oc.to/589UH1">Borg: The Predecessor to Kubernetes</a>:
</p>

<p class="quote">
    Kubernetes traces its lineage directly from Borg. Many of the developers at Google working on Kubernetes were
    formerly developers on the Borg project. We've incorporated the best ideas from Borg in Kubernetes, and have tried
    to address some pain points that users identified with Borg over the years.
</p>

<p>
    In the unlikely event that you managed to get your abstractions just right first time, there is little practical
    difference between the three responsibility models, as the resulting solutions will all remain mostly unchanged
    from the initial artifact generated by your IDP. However, in the more likely event that your abstractions require
    refinement, the shared responsibility model allows you to work with your customers to evolve your abstractions, and
    the customer responsibility model allows customers to make whatever changes they need.
</p>

<div><img class="icon" alt="Anecdotes Icon" src="images/anecdote.png"/></div>

<p><i>
    I was part of a team that designed new steps in Octopus to deploy applications to Kubernetes and AWS ECS. One of the
    challenges in designing these steps was deciding how to support use cases we hadn't anticipated or might be
    introduced
    by the underlying platforms after our steps were released. After spending some time thinking about all the hooks or
    custom scripting we could expose in these steps, we decided that the best course of action was to offer both
    highly opinionated steps that supported most common use cases and generic steps that allowed the deployment of
    raw YAML for either Kubernetes resources or CloudFormation templates. Importantly, the opinionated steps offered a
    way
    to export the equivalent YAML they would generate, giving customers a way to jump from the opinionated step
    (which aligns with the central responsibility model) to the generic step (which aligns with the customer
    responsibility model).
</i></p>

<p><i>
    This kind of "break glass in emergency" process to move from one responsibility model to another meant we could
    offer a path for any customers blocked by a lack of functionality in the opinionated steps, with the understanding
    that customers had to take more responsibility for what was now considered bespoke YAML. This is a practical, and
    now battle tested, example of the responsibility models in action.
</i></p>

<h2>Example Checklist</h2>

<p>This example checklist lists artifacts produced by the IDP and defines the responsibility model associated with each.
    Strategies for minimizing the impact of customer-edited artifacts are noted, with policies limiting changes or the
    process of updating artifacts delegated to the customer.</p>

<table>
    <tr>
        <td>Artifact</td>
        <td>Responsibility Model</td>
    </tr>
    <tr>
        <td>
            Database backup scripts
        </td>
        <td>
            Centralized
        </td>
    </tr>
    <tr>
        <td>
            Microservice deployment processes
        </td>
        <td>
            Shared with updates pushed centrally
        </td>
    </tr>
    <tr>
        <td>
            Microservice bootstrap code projects
        </td>
        <td>
            Customer
        </td>
    </tr>
    <tr>
        <td>
            Virtual Machine creation and destruction scripts
        </td>
        <td>
            Centralized
        </td>
    </tr>
    <tr>
        <td>
            Serverless deployment process
        </td>
        <td>
            Shared with policy enforcing required approval and reporting steps
        </td>
    </tr>
    <tr>
        <td>
            Linux app deployment process
        </td>
        <td>
            Shared with customers pulling in changes
        </td>
    </tr>
</table>

<h2>Conclusion</h2>

<p>DevOps teams have always been able to duplicate artifacts, as most tools have some form of copy-and-paste
    functionality. While building high-quality upstream artifacts is an essential function for any platform team, much
    of the value derived from an IDP is its ability to distribute updates while still allowing customers to edit their
    artifacts.</p>

<p>The customer, shared, and centralized responsibility models allow platform teams to be transparent about who is
    responsible for maintaining long-lived artifacts. While allowing customers to edit their artifacts is an effective
    strategy against the platform team becoming a blocker, the responsibility triad shows that they come at the cost of
    being able to update the artifacts or deploy large numbers of them centrally.</p>